<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Flash Recall</title>
    <style>
      :root {
        color-scheme: light;
        --ink: #111827;
        --muted: #6b7280;
        --border: #111827;
        --panel: #ffffff;
        --panel-muted: #f3f4f6;
        --card: #ffffff;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        font-family: "Courier New", "Lucida Console", monospace;
        color: var(--ink);
        min-height: 100vh;
        background: #ffffff;
        display: grid;
        place-items: center;
        padding: 2rem 1.2rem 3rem;
        -webkit-font-smoothing: none;
        font-smooth: never;
      }
      main {
        width: min(1020px, 96vw);
        background: #ffffff;
        border-radius: 0;
        border: 2px solid var(--border);
        box-shadow: none;
        padding: 2rem;
      }
      body[data-state="idle"] main {
        width: min(420px, 92vw);
        padding: 1.6rem;
      }
      header {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        justify-content: space-between;
        gap: 1rem;
      }
      h1 {
        margin: 0;
        font-size: clamp(1.8rem, 3vw, 2.6rem);
        letter-spacing: 0.08em;
        text-transform: uppercase;
      }
      .tagline {
        background: var(--panel-muted);
        padding: 0.45rem 0.9rem;
        border-radius: 0;
        font-size: 0.9rem;
        border: 2px solid var(--border);
        color: var(--muted);
      }
      .layout {
        display: grid;
        grid-template-columns: minmax(250px, 1fr) 2fr;
        gap: 1.6rem;
        margin-top: 1.6rem;
      }
      body[data-state="idle"] .layout {
        margin-top: 1rem;
      }
      .panel {
        border: 2px solid var(--border);
        border-radius: 0;
        padding: 1.2rem;
        background: var(--panel);
      }
      .stage.panel {
        position: relative;
      }
      body[data-state="idle"] .panel {
        background: transparent;
        border: none;
        box-shadow: none;
        padding: 0;
      }
      .panel h2 {
        margin: 0 0 0.8rem 0;
        font-size: 1.15rem;
        letter-spacing: 0.02em;
      }
      .controls {
        display: grid;
        gap: 1rem;
      }
      .control-group {
        display: grid;
        gap: 0.45rem;
      }
      .control-group label {
        font-weight: 600;
        font-size: 0.92rem;
        color: var(--ink);
      }
      .control-group select,
      .control-group input[type="number"] {
        width: 100%;
        padding: 0.55rem 0.7rem;
        font-size: 0.95rem;
        border-radius: 0;
        border: 2px solid var(--border);
        background: #ffffff;
        color: var(--ink);
      }
      .checkboxes {
        display: grid;
        gap: 0.4rem;
        font-size: 0.92rem;
        color: var(--ink);
      }
      .checkboxes label {
        display: flex;
        align-items: center;
        gap: 0.5rem;
      }
      .actions {
        display: flex;
        flex-wrap: wrap;
        gap: 0.7rem;
      }
      button {
        border: 2px solid var(--border);
        background: #ffffff;
        color: var(--ink);
        padding: 0.6rem 1.4rem;
        border-radius: 0;
        font-size: 0.95rem;
        cursor: pointer;
        letter-spacing: 0.02em;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
        box-shadow: none;
      }
      button.secondary {
        background: var(--panel-muted);
        color: var(--ink);
        border-color: var(--border);
        box-shadow: none;
      }
      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        transform: none;
        box-shadow: none;
      }
      button:hover:not(:disabled) {
        transform: translateY(-2px);
      }
      .stage {
        display: grid;
        gap: 1rem;
      }
      .stage .status,
      .stage .actions,
      #inputGrid,
      #resultsPanel,
      #draftPanel {
        display: none;
      }
      body[data-state="idle"] header {
        display: flex;
      }
      body[data-state="idle"] .layout aside {
        display: block;
      }
      body[data-state="idle"] .layout .stage {
        display: none;
      }
      body[data-state="idle"] .layout {
        grid-template-columns: 1fr;
      }
      body[data-state="show"] header,
      body[data-state="show"] .layout aside,
      body[data-state="recall"] header,
      body[data-state="recall"] .layout aside,
      body[data-state="result"] header,
      body[data-state="result"] .layout aside {
        display: none;
      }
      body[data-state="show"] .layout,
      body[data-state="recall"] .layout,
      body[data-state="result"] .layout {
        grid-template-columns: 1fr;
      }
      body[data-state="recall"] #inputGrid {
        display: grid;
      }
      body[data-state="show"] .timer-bar,
      body[data-state="recall"] .timer-bar {
        display: block;
      }
      body[data-state="result"] .stage .actions {
        display: flex;
      }
      body[data-state="result"] #resultsPanel {
        display: block;
      }
      body[data-state="draft"] header {
        display: none;
      }
      body[data-state="draft"] .layout aside {
        display: none;
      }
      body[data-state="draft"] .layout {
        grid-template-columns: 1fr;
      }
      body[data-state="draft"] .stage .status {
        display: flex;
      }
      body[data-state="draft"] #draftPanel {
        display: block;
      }
      body[data-state="paused"] header,
      body[data-state="paused"] .layout aside {
        display: none;
      }
      body[data-state="paused"] .layout {
        grid-template-columns: 1fr;
      }
      body[data-state="paused"] .stage .status {
        display: flex;
      }
      .status {
        display: flex;
        flex-wrap: wrap;
        gap: 1rem;
        align-items: center;
      }
      .status .pill {
        background: var(--panel-muted);
        border: 2px solid var(--border);
        border-radius: 0;
        padding: 0.35rem 0.9rem;
        font-size: 0.85rem;
        letter-spacing: 0.02em;
      }
      .timer-bar {
        display: none;
        height: 10px;
        border-radius: 0;
        background: #f3f4f6;
        border: 2px solid var(--border);
        overflow: hidden;
      }
      .timer-bar__fill {
        height: 100%;
        width: 100%;
        background: #111827;
        transition: width 0.1s linear;
      }
      .platformer {
        display: none;
      }
      .platformer.panel {
        padding: 0.8rem;
      }
      .platformer-header {
        font-size: 0.8rem;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--muted);
        margin-bottom: 0.4rem;
      }
      .platformer canvas {
        width: 100%;
        height: 160px;
        display: block;
        image-rendering: pixelated;
        background: #f3f4f6;
        border: 2px solid var(--border);
      }
      body.platformer-active .platformer {
        display: block;
      }
      .cards {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
        gap: 1rem;
      }
      .card {
        border: 2px solid var(--border);
        border-radius: 0;
        padding: 1.1rem;
        background: #ffffff;
        min-height: 120px;
        display: grid;
        place-items: center;
        text-align: center;
        font-size: 1.9rem;
        font-weight: 800;
        letter-spacing: 0.04em;
        text-transform: uppercase;
        color: var(--ink);
        box-shadow: none;
        animation: rise 0.4s ease;
      }
      .card small {
        display: block;
        font-size: 0.7rem;
        font-weight: 600;
        letter-spacing: 0.1em;
        text-transform: uppercase;
      }
      .hidden-card small {
        font-size: 1rem;
        letter-spacing: 0.06em;
      }
      .hidden-card {
        background: #111827;
        color: #ffffff;
        font-size: 1.1rem;
        border-color: #111827;
      }
      .hidden-card span {
        font-size: 1rem;
        letter-spacing: 0.06em;
      }
      .glitch {
        position: relative;
        overflow: hidden;
      }
      .glitch::after {
        content: "";
        position: absolute;
        inset: 0;
        background: #000000;
        opacity: 0;
      }
      .glitch.active::after {
        opacity: 1;
      }
      .hidden-card.hint {
        background: #111827;
        color: #ffffff;
        font-size: 1.1rem;
        letter-spacing: 0.06em;
        border-color: #111827;
      }
      .inputs {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
        gap: 0.8rem;
      }
      .inputs input {
        width: 100%;
        padding: 0.6rem 0.8rem;
        border-radius: 0;
        border: 2px solid var(--border);
        font-size: 0.95rem;
        background: #ffffff;
        color: var(--ink);
      }
      .results {
        border-radius: 0;
        border: 2px solid var(--border);
        padding: 1rem;
        background: var(--panel);
        display: none;
      }
      .results.show {
        display: block;
      }
      .results ul {
        list-style: none;
        padding: 0;
        margin: 0.4rem 0 0;
        display: grid;
        gap: 0.35rem;
      }
      .results li {
        display: flex;
        justify-content: space-between;
        gap: 1rem;
        font-size: 0.95rem;
      }
      .result-expected {
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
        flex-wrap: wrap;
      }
      .result-label {
        font-size: 0.8rem;
        text-transform: uppercase;
        letter-spacing: 0.1em;
        color: var(--muted);
      }
      .result-answer {
        font-weight: 700;
        font-size: 1rem;
        color: var(--ink);
      }
      .draft {
        border-radius: 0;
        border: 2px solid var(--border);
        padding: 1rem;
        background: var(--panel);
        display: none;
      }
      .draft h3 {
        margin: 0 0 0.7rem;
        font-size: 1.1rem;
        letter-spacing: 0.04em;
      }
      .draft-grid {
        display: grid;
        gap: 0.8rem;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      }
      .draft-card {
        text-align: left;
        border: 2px solid var(--border);
        border-radius: 0;
        padding: 0.9rem;
        background: #ffffff;
        color: var(--ink);
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .draft-card:hover {
        transform: translateY(-2px);
        box-shadow: none;
      }
      .draft-card strong {
        display: block;
        margin-bottom: 0.3rem;
      }
      .draft-card small {
        display: block;
        font-size: 0.75rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
        color: var(--muted);
      }
      body[data-mode="adventure"] .practice-only {
        display: none;
      }
      body[data-mode="practice"] .adventure-only {
        display: none;
      }
      .mode-grid {
        display: grid;
        gap: 1rem;
        justify-items: center;
      }
      .mode-card {
        max-width: 360px;
        width: 100%;
        justify-self: center;
        border: 2px solid var(--border);
        background: #ffffff;
        color: var(--ink);
        padding: 1rem 1.2rem;
        border-radius: 0;
        display: grid;
        gap: 0.4rem;
        text-align: left;
        cursor: pointer;
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      .mode-card strong {
        font-size: 1.1rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }
      .mode-card span {
        font-size: 0.92rem;
        color: var(--muted);
      }
      .mode-card:hover {
        transform: translateY(-2px);
        box-shadow: none;
      }
      .badge {
        font-weight: 600;
        padding: 0.2rem 0.6rem;
        border-radius: 0;
        border: 2px solid var(--border);
        font-size: 0.75rem;
        letter-spacing: 0.06em;
      }
      .good {
        background: #ecfdf3;
      }
      .bad {
        background: #fef2f2;
      }
      .modal {
        position: fixed;
        inset: 0;
        display: none;
        place-items: center;
        background: rgba(17, 24, 39, 0.25);
        z-index: 10;
        padding: 1.5rem;
      }
      .modal--pause {
        background: rgba(17, 24, 39, 0.5);
      }
      body.pause-active main {
        filter: blur(6px) grayscale(0.6);
        opacity: 0.35;
        pointer-events: none;
      }
      .modal.show {
        display: grid;
      }
      .modal-card {
        width: min(520px, 92vw);
        background: #ffffff;
        border: 2px solid var(--border);
        border-radius: 0;
        padding: 1.4rem;
        box-shadow: none;
      }
      .modal-card h3 {
        margin: 0 0 0.8rem;
        font-size: 1.1rem;
        letter-spacing: 0.06em;
        text-transform: uppercase;
      }
      .modal-card .controls {
        gap: 0.9rem;
      }
      .modal-actions {
        display: flex;
        gap: 0.8rem;
        justify-content: flex-end;
        margin-top: 1rem;
      }
      .interrupt-modal {
        position: fixed;
        display: none;
        place-items: center;
        z-index: 12;
      }
      .interrupt-modal.show {
        display: grid;
      }
      .interrupt-card {
        width: min(420px, 90vw);
        background: #ffffff;
        border: 2px solid var(--border);
        padding: 1rem;
        display: grid;
        gap: 0.6rem;
        pointer-events: auto;
        position: relative;
      }
      .interrupt-header {
        min-height: 1.1rem;
      }
      .interrupt-close {
        border: 2px solid var(--border);
        background: #ffffff;
        padding: 0.2rem 0.4rem;
        cursor: pointer;
        font-size: 0.8rem;
        position: absolute;
        top: 0.6rem;
        right: 0.6rem;
      }
      .interrupt-body {
        border: 2px dashed var(--border);
        padding: 1.4rem;
        font-size: 0.95rem;
        color: var(--muted);
      }
      .config-hidden {
        display: none;
      }
      .fog-overlay {
        position: fixed;
        inset: 0;
        display: none;
        z-index: 20;
        pointer-events: none;
      }
      @keyframes rise {
        from {
          opacity: 0;
          transform: translateY(8px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
      @media (max-width: 860px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header>
        <h1>Flash Recall</h1>
      </header>
      <section class="layout">
        <aside class="panel">
          <h2>Choose Mode</h2>
          <div class="controls">
            <div class="mode-grid">
              <button id="practiceStart" class="mode-card" type="button">
                <strong>Practice</strong>
                <span>Free play with your current ruleset.</span>
              </button>
              <button id="adventureStart" class="mode-card" type="button">
                <strong>Adventure</strong>
                <span>Draft modifiers, gain points, manage lives.</span>
              </button>
            </div>
          </div>
        </aside>
        <section class="stage panel">
          <div class="status">
            <div class="pill" id="modePill">Mode: Practice</div>
            <div class="pill" id="phasePill">Waiting to start</div>
            <div class="pill" id="timerPill">00</div>
            <div class="pill" id="roundPill">Round 0</div>
            <div class="pill" id="scorePill">Streak 0</div>
            <div class="pill" id="livesPill">Lives 3</div>
          </div>
          <div class="timer-bar" id="timerBar">
            <div class="timer-bar__fill" id="timerFill"></div>
          </div>
          <div class="cards" id="cardGrid"></div>
          <div class="inputs" id="inputGrid"></div>
          <div class="platformer panel" id="platformerPanel">
            <div class="platformer-header">Platformer</div>
            <canvas id="platformerCanvas" width="900" height="160"></canvas>
          </div>
          <div class="actions"></div>
          <div class="results" id="resultsPanel"></div>
          <div class="draft" id="draftPanel">
            <h3>Choose a modifier</h3>
            <div class="draft-grid" id="draftGrid"></div>
          </div>
        </section>
      </section>
    </main>
    <div class="modal" id="practiceModal" aria-hidden="true">
      <div class="modal-card">
        <h3>Practice Settings</h3>
        <div class="controls">
          <div class="control-group">
            <label for="revealTime">Reveal time (seconds)</label>
            <input id="revealTime" type="number" min="2" max="20" step="1" value="10" />
          </div>
          <div class="control-group">
            <label for="recallTime">Recall time (seconds)</label>
            <input id="recallTime" type="number" min="5" max="30" step="1" value="15" />
          </div>
          <div class="control-group">
            <label for="cardCount">Number of cards (1-10)</label>
            <input id="cardCount" type="number" min="1" max="10" step="1" value="4" />
          </div>
          <div class="control-group">
            <label>Card types</label>
            <div class="checkboxes">
              <label><input type="checkbox" value="numbers" checked />Numbers</label>
              <label><input type="checkbox" value="colors" checked />Colors</label>
              <label><input type="checkbox" value="letters" checked />Letters</label>
              <label><input type="checkbox" value="directions" checked />Directions</label>
            </div>
          </div>
          <div class="control-group">
            <label>Modifiers</label>
            <div class="checkboxes">
              <label><input id="practiceMathOps" type="checkbox" checked />Math ops</label>
              <label><input id="practiceMisleadColors" type="checkbox" checked />Misleading colors</label>
              <label><input id="practiceBackgroundColor" type="checkbox" checked />Background color</label>
              <label><input id="practicePlatformer" type="checkbox" />Platformer recall</label>
              <label><input id="practiceGlitch" type="checkbox" />Glitching reveal</label>
              <label><input id="practiceFog" type="checkbox" />Fog reveal</label>
              <label><input id="practiceAds" type="checkbox" />Pop-up ads</label>
            </div>
          </div>
        </div>
        <div class="modal-actions">
          <button id="practiceCancel" class="secondary" type="button">Back</button>
          <button id="practiceConfirm" type="button">Start Practice</button>
        </div>
      </div>
    </div>
    <div class="modal modal--pause" id="pauseModal" aria-hidden="true">
      <div class="modal-card">
        <h3>Paused</h3>
        <div class="modal-actions">
          <button id="pauseResume" class="secondary" type="button">Resume</button>
          <button id="pauseRestart" type="button">Restart</button>
          <button id="pauseQuit" type="button">Quit</button>
        </div>
      </div>
    </div>
    <div class="interrupt-modal" id="interruptModal" aria-hidden="true">
      <div class="interrupt-card">
        <div class="interrupt-header">
          <button class="interrupt-close" id="interruptClose" type="button">X</button>
        </div>
        <div class="interrupt-body">Pop-up block</div>
      </div>
    </div>
    <canvas class="fog-overlay" id="fogCanvas"></canvas>
    <div class="config-hidden">
      <select id="modeSelect">
        <option value="practice" selected>Practice</option>
        <option value="adventure">Adventure</option>
      </select>
    </div>
    <script>
      const dataSets = {
        numbers: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10"],
        colors: [
          { label: "Red", color: "#ef4444" },
          { label: "Blue", color: "#3b82f6" },
          { label: "Yellow", color: "#facc15" },
          { label: "Green", color: "#22c55e" },
          { label: "White", color: "#f8fafc" },
          { label: "Orange", color: "#f97316" },
          { label: "Pink", color: "#ec4899" },
          { label: "Brown", color: "#8b5e34" },
          { label: "Purple", color: "#8b5cf6" }
        ],
        letters: ["A", "B", "C", "D", "E", "F", "G", "H", "J", "K"],
        directions: [
          { label: "Up", symbol: "↑" },
          { label: "Right", symbol: "→" },
          { label: "Left", symbol: "←" },
          { label: "Down", symbol: "↓" }
        ]
      };
      const backgroundColors = [
        { label: "Red", color: "#ef4444" },
        { label: "Blue", color: "#3b82f6" },
        { label: "Green", color: "#22c55e" },
        { label: "Orange", color: "#f97316" },
        { label: "Pink", color: "#ec4899" },
        { label: "Brown", color: "#8b5e34" },
        { label: "Purple", color: "#8b5cf6" }
      ];

      const revealInput = document.getElementById("revealTime");
      const recallInput = document.getElementById("recallTime");
      const practiceStart = document.getElementById("practiceStart");
      const adventureStart = document.getElementById("adventureStart");
      const submitBtn = document.getElementById("submitBtn");
      const nextBtn = document.getElementById("nextBtn");
      const practiceModal = document.getElementById("practiceModal");
      const practiceCancel = document.getElementById("practiceCancel");
      const practiceConfirm = document.getElementById("practiceConfirm");
      const cardCountInput = document.getElementById("cardCount");
      const practicePlatformer = document.getElementById("practicePlatformer");
      const practiceGlitch = document.getElementById("practiceGlitch");
      const practiceFog = document.getElementById("practiceFog");
      const practiceAds = document.getElementById("practiceAds");
      const pauseModal = document.getElementById("pauseModal");
      const pauseResume = document.getElementById("pauseResume");
      const pauseRestart = document.getElementById("pauseRestart");
      const pauseQuit = document.getElementById("pauseQuit");
      const interruptModal = document.getElementById("interruptModal");
      const interruptClose = document.getElementById("interruptClose");
      const interruptCard = interruptModal
        ? interruptModal.querySelector(".interrupt-card")
        : null;
      const practiceMathOps = document.getElementById("practiceMathOps");
      const practiceMisleadColors = document.getElementById("practiceMisleadColors");
      const practiceBackgroundColor = document.getElementById("practiceBackgroundColor");
      const modeSelect = document.getElementById("modeSelect");
      const phasePill = document.getElementById("phasePill");
      const timerPill = document.getElementById("timerPill");
      const timerBar = document.getElementById("timerBar");
      const timerFill = document.getElementById("timerFill");
      const modePill = document.getElementById("modePill");
      const roundPill = document.getElementById("roundPill");
      const scorePill = document.getElementById("scorePill");
      const livesPill = document.getElementById("livesPill");
      const cardGrid = document.getElementById("cardGrid");
      const inputGrid = document.getElementById("inputGrid");
      const resultsPanel = document.getElementById("resultsPanel");
      const draftPanel = document.getElementById("draftPanel");
      const draftGrid = document.getElementById("draftGrid");
      const platformerPanel = document.getElementById("platformerPanel");
      const platformerCanvas = document.getElementById("platformerCanvas");
      const platformerCtx = platformerCanvas.getContext("2d");
      const fogCanvas = document.getElementById("fogCanvas");
      const fogCtx = fogCanvas.getContext("2d");
      const page = document.body;

      let phase = "idle";
      let round = 0;
      let streak = 0;
      let timerId = null;
      let roundItems = [];
      let roundItemsBase = [];
      let gameMode = "practice";
      let pausedState = null;
      let timerState = null;
      const platformerState = {
        enabled: false,
        completed: false,
        required: false,
        failed: false,
        player: { x: 20, y: 0, w: 16, h: 20, vx: 0, vy: 0 },
        start: { x: 20, y: 0 },
        platforms: [],
        pits: [],
        goal: { x: 0, y: 0, w: 12, h: 20 },
        keys: { left: false, right: false, jump: false }
      };
      let adTimer = null;
      let adEnabled = false;
      let adActive = false;
      let adShownThisRound = false;
      let pendingSkipAfterAd = false;
      let fogEnabled = false;
      let fogActive = false;
      let fogLastMove = { x: null, y: null, t: 0 };
      let glitchTimer = null;
      const adventureState = {
        lives: 3,
        score: 0,
        difficulty: 0,
        modifiers: {
          revealPenalty: 0,
          cardCount: 1
        },
        unlockedCategories: ["numbers"]
      };

      function getSelectedCategories() {
        return Array.from(document.querySelectorAll(".checkboxes input:checked"))
          .map((checkbox) => checkbox.value)
          .filter((value) => dataSets[value]);
      }

      function getActiveCategories(currentRound) {
        if (gameMode === "adventure") {
          return [...adventureState.unlockedCategories];
        }
        return getSelectedCategories();
      }

      function getChallengeOptions(currentRound) {
        if (gameMode === "adventure") {
          const colorsUnlocked = adventureState.unlockedCategories.includes("colors");
          return {
            enableMathOps: Boolean(adventureState.modifiers.mathOps),
            mathChance: 0.6,
            misleadColors: colorsUnlocked && Boolean(adventureState.modifiers.misleadColors),
            misleadChance: 0.6,
            enableBackgroundColor: Boolean(adventureState.modifiers.backgroundColor),
            backgroundColorChance: 0.35,
            enableGlitch: Boolean(adventureState.modifiers.glitch)
          };
        }
        return {
          enableMathOps: practiceMathOps.checked,
          mathChance: 0.7,
          misleadColors: practiceMisleadColors.checked,
          misleadChance: 0.6,
          enableBackgroundColor: practiceBackgroundColor.checked,
          backgroundColorChance: 0.35,
          enableGlitch: practiceGlitch.checked
        };
      }

      function setGlitchActive(active) {
        document.querySelectorAll(".card").forEach((card) => {
          if (active) {
            card.classList.add("glitch", "active");
          } else {
            card.classList.remove("active");
          }
        });
      }

      function startGlitching() {
        stopGlitching();
        if (!getChallengeOptions(round).enableGlitch) return;
        glitchTimer = setInterval(() => {
          const flicker = Math.random() < 0.4;
          setGlitchActive(flicker);
          if (!flicker) {
            setGlitchActive(false);
          }
        }, 350);
      }

      function stopGlitching() {
        if (glitchTimer) {
          clearInterval(glitchTimer);
          glitchTimer = null;
        }
        setGlitchActive(false);
      }

      function isPlatformerEnabled() {
        return gameMode === "adventure"
          ? Boolean(adventureState.modifiers.platformer)
          : Boolean(practicePlatformer.checked);
      }

      function isAdEnabled() {
        return gameMode === "adventure"
          ? Boolean(adventureState.modifiers.ads)
          : Boolean(practiceAds.checked);
      }

      function isFogEnabled() {
        return gameMode === "adventure"
          ? Boolean(adventureState.modifiers.fog)
          : Boolean(practiceFog.checked);
      }

      function showAd() {
        if (!adEnabled) return;
        if (adActive) return;
        if (phase !== "show") return;
        if (!interruptModal) return;
        if (document.activeElement && document.activeElement.blur) {
          document.activeElement.blur();
        }
        setModalState(interruptModal, true);
        interruptModal.style.display = "grid";
        positionAd();
        if (interruptClose) {
          interruptClose.focus();
        }
        adActive = true;
        adShownThisRound = true;
      }

      function hideAd() {
        setModalState(interruptModal, false);
        interruptModal.style.display = "none";
        adActive = false;
      }

      function clearAdTimer() {
        if (adTimer) {
          clearTimeout(adTimer);
          adTimer = null;
        }
      }

      function resizeFog() {
        if (!fogCanvas) return;
        fogCanvas.width = window.innerWidth;
        fogCanvas.height = window.innerHeight;
      }

      function drawFog() {
        if (!fogCtx || !fogCanvas) return;
        fogCtx.globalCompositeOperation = "source-over";
        fogCtx.clearRect(0, 0, fogCanvas.width, fogCanvas.height);
        const fogCount = Math.round((fogCanvas.width * fogCanvas.height) / 90000);
        for (let i = 0; i < fogCount; i += 1) {
          const x = Math.random() * fogCanvas.width;
          const y = Math.random() * fogCanvas.height;
          const radius = 60 + Math.random() * 120;
          const gradient = fogCtx.createRadialGradient(x, y, radius * 0.2, x, y, radius);
          gradient.addColorStop(0, "rgba(255, 255, 255, 0.9)");
          gradient.addColorStop(1, "rgba(255, 255, 255, 0)");
          fogCtx.fillStyle = gradient;
          fogCtx.beginPath();
          fogCtx.arc(x, y, radius, 0, Math.PI * 2);
          fogCtx.fill();
        }
      }

      function startFog() {
        if (!fogCanvas) return;
        fogActive = true;
        fogCanvas.style.display = "block";
        resizeFog();
        drawFog();
        fogLastMove = { x: null, y: null, t: 0 };
      }

      function stopFog() {
        fogActive = false;
        if (fogCanvas) {
          fogCanvas.style.display = "none";
        }
      }

      function clearFogAt(x, y, speed, lastX, lastY) {
        if (!fogCtx || !fogCanvas) return;
        const strength = Math.min(1, speed / 1.1);
        const width = 24 + strength * 60;
        fogCtx.globalCompositeOperation = "destination-out";
        fogCtx.lineCap = "round";
        fogCtx.lineJoin = "round";
        fogCtx.lineWidth = width;
        fogCtx.beginPath();
        if (lastX !== null && lastY !== null) {
          fogCtx.moveTo(lastX, lastY);
        } else {
          fogCtx.moveTo(x, y);
        }
        fogCtx.lineTo(x, y);
        fogCtx.stroke();
        fogCtx.beginPath();
        fogCtx.arc(x, y, width * 0.6, 0, Math.PI * 2);
        fogCtx.fill();
        fogCtx.globalCompositeOperation = "source-over";
      }

      function positionAd() {
        if (!interruptModal || !interruptCard || !cardGrid) return;
        const sizeOptions = [
          { w: 240, h: 140 },
          { w: 280, h: 160 },
          { w: 320, h: 180 },
          { w: 360, h: 200 }
        ];
        const chosenSize = sizeOptions[Math.floor(Math.random() * sizeOptions.length)];
        interruptCard.style.width = `${chosenSize.w}px`;
        interruptCard.style.minHeight = `${chosenSize.h}px`;
        const gridRect = cardGrid.getBoundingClientRect();
        const cardRect = interruptCard.getBoundingClientRect();
        const overflow = 24;
        const safePadding = 8;
        let minLeft = gridRect.left - overflow;
        let maxLeft = gridRect.right - cardRect.width + overflow;
        let minTop = gridRect.top - overflow;
        let maxTop = gridRect.bottom - cardRect.height + overflow;
        const maxLeftBound = window.innerWidth - cardRect.width - safePadding;
        const maxTopBound = window.innerHeight - cardRect.height - safePadding;
        minLeft = Math.max(minLeft, safePadding);
        maxLeft = Math.min(maxLeft, maxLeftBound);
        minTop = Math.max(minTop, safePadding);
        maxTop = Math.min(maxTop, maxTopBound);
        const left = minLeft + Math.random() * Math.max(0, maxLeft - minLeft);
        const top = minTop + Math.random() * Math.max(0, maxTop - minTop);
        interruptModal.style.left = `${left}px`;
        interruptModal.style.top = `${top}px`;
      }

      function scheduleAd(revealSeconds) {
        clearAdTimer();
        if (!adEnabled) return;
        const thirdWindow = Math.max(0.1, revealSeconds / 3);
        const minDelay = 0.05;
        const maxDelay = Math.max(minDelay, thirdWindow - 0.1);
        const delaySeconds = minDelay + Math.random() * (maxDelay - minDelay);
        adTimer = setTimeout(() => {
          requestAnimationFrame(() => {
            showAd();
          });
        }, delaySeconds * 1000);
      }

      function queueSkipAfterAd() {
        if (!adEnabled || adShownThisRound) {
          beginRecallPhase();
          return;
        }
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        timerState = null;
        clearAdTimer();
        pendingSkipAfterAd = true;
        showAd();
      }

      function updateModeUI() {
        gameMode = modeSelect.value;
        page.dataset.mode = gameMode;
        updateCategoryControls();
        updateScore();
      }

      function updateCategoryControls() {
        const disabled = gameMode === "adventure";
        document.querySelectorAll(".checkboxes input").forEach((input) => {
          input.disabled = disabled;
        });
        if (practiceMathOps) {
          practiceMathOps.disabled = false;
        }
        if (practiceMisleadColors) {
          practiceMisleadColors.disabled = false;
        }
        if (practiceBackgroundColor) {
          practiceBackgroundColor.disabled = false;
        }
        if (practiceGlitch) {
          practiceGlitch.disabled = false;
        }
        if (practiceFog) {
          practiceFog.disabled = false;
        }
        if (practiceAds) {
          practiceAds.disabled = false;
        }
      }

      function setPhase(text, nextState) {
        phasePill.textContent = text;
        if (nextState) {
          phase = nextState;
          page.dataset.state = nextState;
        }
      }

      function updateScore() {
        roundPill.textContent = `Round ${round}`;
        if (gameMode === "adventure") {
          modePill.textContent = "Mode: Adventure";
          scorePill.textContent = `Score ${adventureState.score}`;
          livesPill.textContent = `Lives ${adventureState.lives}`;
        } else {
          modePill.textContent = "Mode: Practice";
          scorePill.textContent = `Streak ${streak}`;
          livesPill.textContent = "Lives -";
        }
      }

      function resetBoard() {
        cardGrid.innerHTML = "";
        inputGrid.innerHTML = "";
        resultsPanel.classList.remove("show");
        resultsPanel.innerHTML = "";
        draftGrid.innerHTML = "";
      }

      function normalize(value) {
        return value.trim().toLowerCase();
      }

      function formatCategoryLabel(category) {
        switch (category) {
          case "numbers":
            return "Number";
          case "letters":
            return "Letter";
          case "colors":
            return "Color";
          case "directions":
            return "Direction";
          default:
            return category ? category[0].toUpperCase() + category.slice(1) : "Card";
        }
      }

      function isCorrectAnswer(item, actualValue) {
        const actual = normalize(actualValue);
        const expected = normalize(item.answer ?? item.label);
        if (item.category === "colors") {
          const initial = expected.charAt(0);
          return actual === expected || actual === initial;
        }
        if (item.category === "directions") {
          const initial = expected.charAt(0);
          return actual === expected || actual === initial;
        }
        if (item.recallHint === "Background color") {
          const initial = expected.charAt(0);
          return actual === expected || actual === initial;
        }
        return actual === expected;
      }

      function pickMisleadingLabel(actualLabel) {
        const options = dataSets.colors
          .map((color) => color.label)
          .filter((label) => label.toLowerCase() !== actualLabel.toLowerCase());
        return options[Math.floor(Math.random() * options.length)];
      }

      function pickBackgroundColor() {
        return backgroundColors[Math.floor(Math.random() * backgroundColors.length)];
      }

      function buildChallenge(item, options) {
        const challenge = {
          ...item,
          answer: item.label,
          recallHint: null,
          textLabel: null,
          colorTarget: null,
          backgroundColorLabel: null,
          backgroundColorHex: null
        };
        if (item.category === "colors") {
          if (options.misleadColors && Math.random() < options.misleadChance) {
            challenge.misleadingLabel = pickMisleadingLabel(item.label);
          }
          challenge.textLabel = challenge.misleadingLabel || challenge.label;
          challenge.colorTarget = Math.random() < 0.5 ? "background" : "text";
          if (challenge.colorTarget === "background") {
            challenge.answer = challenge.label;
            challenge.recallHint = "Background color";
          } else {
            challenge.answer = challenge.textLabel;
            challenge.recallHint = "Color text";
          }
        } else if (options.enableBackgroundColor && Math.random() < options.backgroundColorChance) {
          const backgroundColor = pickBackgroundColor();
          challenge.backgroundColorLabel = backgroundColor.label;
          challenge.backgroundColorHex = backgroundColor.color;
          challenge.answer = backgroundColor.label;
          challenge.recallHint = "Background color";
        }
        return challenge;
      }

      function applyNumberChallenge(item) {
        const base = Number(item.label);
        const ops = [
          { label: "Add", sign: "+", fn: (value, n) => value + n },
          { label: "Subtract", sign: "-", fn: (value, n) => value - n },
          { label: "Multiply by", sign: "×", fn: (value, n) => value * n, multiplier: true }
        ];
        let op = ops[Math.floor(Math.random() * ops.length)];
        const delta = op.multiplier ? 2 + Math.floor(Math.random() * 2) : 1 + Math.floor(Math.random() * 3);
        if (op.sign === "-" && base - delta < 0) {
          op = ops[0];
        }
        let recallHint = "";
        if (op.sign === "+") {
          recallHint = `+ ${delta}`;
        } else if (op.sign === "-") {
          recallHint = `- ${delta}`;
        } else {
          recallHint = `* ${delta}`;
        }
        return {
          ...item,
          recallHint,
          answer: String(op.fn(base, delta))
        };
      }

      function applyNumberChallenges(items, options) {
        if (!options.enableMathOps) return items;
        const candidates = items
          .map((item, index) => ({ item, index }))
          .filter((entry) => entry.item.category === "numbers");
        for (let i = candidates.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [candidates[i], candidates[j]] = [candidates[j], candidates[i]];
        }
        const result = items.map((item) => ({ ...item }));
        let applied = 0;
        for (const entry of candidates) {
          if (applied >= 2) break;
          if (Math.random() >= options.mathChance) continue;
          result[entry.index] = applyNumberChallenge(entry.item);
          applied += 1;
        }
        return result;
      }

      function pickItems() {
        const categories = getActiveCategories(round);
        const options = getChallengeOptions(round);
        const count =
          gameMode === "practice"
            ? Number(cardCountInput.value || 4)
            : adventureState.modifiers.cardCount || 1;
        const chosen = [];
        const used = new Set();
        while (chosen.length < count) {
          const category = categories[Math.floor(Math.random() * categories.length)];
          const list = dataSets[category];
          const rawItem = list[Math.floor(Math.random() * list.length)];
          const item = typeof rawItem === "string" ? { label: rawItem } : rawItem;
          const key = `${category}-${item.label}`.toLowerCase();
          if (used.has(key)) continue;
          used.add(key);
          chosen.push(buildChallenge({ ...item, category }, options));
        }
        return applyNumberChallenges(chosen, options);
      }

      function renderCards(show) {
        cardGrid.innerHTML = "";
        roundItems.forEach((item, index) => {
          const card = document.createElement("div");
          const hintClass = !show && item.recallHint ? " hidden-card hint" : " hidden-card";
          card.className = `card ${show ? "" : hintClass}`.trim();
          if (show) {
            if (item.category === "directions") {
              card.innerHTML = `<small>${item.category}</small>${item.symbol}`;
            } else {
              const cardLabel = item.textLabel ?? item.label;
              const symbol = item.symbol ? `${item.symbol} ` : "";
              card.innerHTML = `<small>${item.category}</small>${symbol}${cardLabel}`;
            }
            if (item.color) {
              card.style.background = item.color;
              card.style.color = "#0f172a";
            } else if (item.backgroundColorHex) {
              card.style.background = item.backgroundColorHex;
              card.style.color = "#0f172a";
              card.classList.add("background-color");
            }
          } else {
            const cardLabel = `Card ${index + 1}`;
            const categoryLabel = formatCategoryLabel(item.category);
            if (item.recallHint) {
              card.innerHTML = `
                <small>${cardLabel}</small>
                <span>${item.recallHint}</span>
              `;
            } else {
              card.innerHTML = `
                <small>${cardLabel}</small>
                <span>${categoryLabel}</span>
              `;
            }
          }
          cardGrid.appendChild(card);
        });
      }

      function renderInputs() {
        inputGrid.innerHTML = "";
        roundItems.forEach((item, index) => {
          const input = document.createElement("input");
          input.type = "text";
          const hint = item.recallHint ? `: ${item.recallHint}` : "";
          input.placeholder = `Card ${index + 1} (${item.category}${hint})`;
          input.dataset.index = index;
          inputGrid.appendChild(input);
        });
      }

      function resetPlatformer() {
        platformerState.completed = false;
        platformerState.failed = false;
        platformerState.player = { x: 20, y: 0, w: 16, h: 20, vx: 0, vy: 0 };
        const layout = generatePlatforms();
        platformerState.platforms = layout.platforms;
        platformerState.pits = layout.pits;
        const ground = platformerState.platforms[0];
        platformerState.player.y = ground.y - platformerState.player.h;
        platformerState.start = { x: platformerState.player.x, y: platformerState.player.y };
        platformerState.goal = {
          x: platformerCanvas.width - 28,
          y: ground.y - 20,
          w: 12,
          h: 20
        };
      }

      function generatePlatforms() {
        const platforms = [];
        const pits = [];
        const groundY = platformerCanvas.height - 20;
        platforms.push({ x: 0, y: groundY, w: platformerCanvas.width, h: 20, isGround: true });
        const pitCount = 1 + Math.floor(Math.random() * 2);
        for (let i = 0; i < pitCount; i += 1) {
          const width = 30 + Math.floor(Math.random() * 30);
          const x = 120 + Math.floor(Math.random() * (platformerCanvas.width - 220));
          pits.push({ x, y: groundY, w: width, h: 20 });
        }
        let x = 80;
        const stepCount = 4 + Math.floor(Math.random() * 2);
        for (let i = 0; i < stepCount; i += 1) {
          const width = 80 + Math.floor(Math.random() * 60);
          const y = groundY - (40 + Math.floor(Math.random() * 80));
          platforms.push({ x, y, w: width, h: 10 });
          x += 120 + Math.floor(Math.random() * 80);
        }
        return { platforms, pits };
      }

      function isOverPit(player) {
        return platformerState.pits.some((pit) => {
          return player.x + player.w > pit.x && player.x < pit.x + pit.w;
        });
      }

      function resetPlayerToStart() {
        const player = platformerState.player;
        player.x = platformerState.start.x;
        player.y = platformerState.start.y;
        player.vx = 0;
        player.vy = 0;
      }

      function updatePlatformer() {
        if (!platformerState.enabled || platformerState.completed) return;
        const player = platformerState.player;
        const speed = 2.6;
        if (platformerState.keys.left) player.vx = -speed;
        else if (platformerState.keys.right) player.vx = speed;
        else player.vx = 0;

        const onGround = isPlayerOnGround();
        if (platformerState.keys.jump && onGround) {
          player.vy = -8.5;
        }
        platformerState.keys.jump = false;

        player.vy += 0.45;
        player.x += player.vx;
        player.y += player.vy;

        if (player.x < 0) player.x = 0;
        if (player.x + player.w > platformerCanvas.width) {
          player.x = platformerCanvas.width - player.w;
        }
        if (player.y + player.h > platformerCanvas.height) {
          resetPlayerToStart();
        }

        platformerState.platforms.forEach((platform) => {
          if (
            player.vy >= 0 &&
            player.x + player.w > platform.x &&
            player.x < platform.x + platform.w &&
            player.y + player.h >= platform.y &&
            player.y + player.h <= platform.y + platform.h + 6
          ) {
            if (platform.isGround && isOverPit(player)) {
              return;
            }
            player.y = platform.y - player.h;
            player.vy = 0;
          }
        });

        if (checkGoalHit()) {
          platformerState.completed = true;
        }
      }

      function isPlayerOnGround() {
        const player = platformerState.player;
        return platformerState.platforms.some((platform) => {
          return (
            player.x + player.w > platform.x &&
            player.x < platform.x + platform.w &&
            Math.abs(player.y + player.h - platform.y) <= 1
          );
        });
      }

      function checkGoalHit() {
        const player = platformerState.player;
        const goal = platformerState.goal;
        return (
          player.x < goal.x + goal.w &&
          player.x + player.w > goal.x &&
          player.y < goal.y + goal.h &&
          player.y + player.h > goal.y
        );
      }

      function drawPlatformer() {
        if (!platformerState.enabled) return;
        platformerCtx.clearRect(0, 0, platformerCanvas.width, platformerCanvas.height);
        platformerCtx.fillStyle = "#e5e7eb";
        platformerCtx.fillRect(0, 0, platformerCanvas.width, platformerCanvas.height);

        platformerCtx.fillStyle = "#111827";
        const ground = platformerState.platforms.find((p) => p.isGround);
        if (ground) {
          const pits = [...platformerState.pits].sort((a, b) => a.x - b.x);
          let cursor = ground.x;
          pits.forEach((pit) => {
            if (pit.x > cursor) {
              platformerCtx.fillRect(cursor, ground.y, pit.x - cursor, ground.h);
            }
            cursor = pit.x + pit.w;
          });
          if (cursor < ground.x + ground.w) {
            platformerCtx.fillRect(cursor, ground.y, ground.x + ground.w - cursor, ground.h);
          }
        }
        platformerState.platforms.forEach((platform) => {
          if (!platform.isGround) {
            platformerCtx.fillRect(platform.x, platform.y, platform.w, platform.h);
          }
        });
        platformerCtx.fillStyle = "#e5e7eb";
        platformerState.pits.forEach((pit) => {
          platformerCtx.fillRect(pit.x, pit.y, pit.w, pit.h);
        });

        platformerCtx.fillStyle = platformerState.completed ? "#22c55e" : "#111827";
        const goal = platformerState.goal;
        platformerCtx.fillRect(goal.x, goal.y, goal.w, goal.h);

        platformerCtx.fillStyle = "#ffffff";
        const player = platformerState.player;
        platformerCtx.fillRect(player.x, player.y, player.w, player.h);
      }

      function updatePlatformerVisibility(active) {
        platformerState.enabled = active;
        if (active) {
          document.body.classList.add("platformer-active");
          resetPlatformer();
        } else {
          document.body.classList.remove("platformer-active");
        }
      }

      function platformerLoop() {
        if (platformerState.enabled && phase === "show" && !pauseModal.classList.contains("show")) {
          updatePlatformer();
          drawPlatformer();
        }
        requestAnimationFrame(platformerLoop);
      }

      function focusFirstInput() {
        const firstInput = inputGrid.querySelector("input");
        if (firstInput) {
          firstInput.focus();
        }
      }

      function setTimer(seconds, label, onComplete, totalSeconds = seconds) {
        clearInterval(timerId);
        const endTime = performance.now() + seconds * 1000;
        timerState = { endTime, seconds, totalSeconds, label, onComplete };
        function tick() {
          const remaining = Math.max(0, timerState.endTime - performance.now());
          const display = `${Math.ceil(remaining / 1000)}s`;
          timerPill.textContent = label ? `${label}: ${display}` : display;
          if (timerFill) {
            const progress = totalSeconds ? remaining / (totalSeconds * 1000) : 0;
            timerFill.style.width = `${Math.max(0, Math.min(1, progress)) * 100}%`;
          }
          if (remaining <= 0) {
            clearInterval(timerId);
            timerId = null;
            timerState = null;
            onComplete();
          }
        }
        tick();
        timerId = setInterval(tick, 100);
      }

      function setModalState(modal, open) {
        if (!modal) return;
        if (open) {
          modal.classList.add("show");
          modal.removeAttribute("aria-hidden");
          modal.removeAttribute("inert");
        } else {
          if (document.activeElement && modal.contains(document.activeElement)) {
            document.activeElement.blur();
          }
          modal.classList.remove("show");
          modal.setAttribute("aria-hidden", "true");
          modal.setAttribute("inert", "");
        }
      }

      function openPauseModal() {
        if (phase === "idle" || phase === "draft") return;
        pausedState = {
          phase,
          phaseText: phasePill.textContent,
          timer: null
        };
        if (timerState) {
          const remainingMs = Math.max(0, timerState.endTime - performance.now());
          pausedState.timer = {
            remainingMs,
            label: timerState.label,
            onComplete: timerState.onComplete,
            totalSeconds: timerState.totalSeconds
          };
        }
        if (timerId) {
          clearInterval(timerId);
          timerId = null;
        }
        timerState = null;
        setModalState(pauseModal, true);
        document.body.classList.add("pause-active");
      }

      function closePauseModal() {
        setModalState(pauseModal, false);
        document.body.classList.remove("pause-active");
      }

      function buildExpectedLabel(item) {
        if (item.category === "numbers" && item.recallHint) {
          return {
            label: item.recallHint,
            answer: item.answer
          };
        }
        if (item.category === "colors") {
          const target = item.recallHint || "Color";
          return {
            label: target,
            answer: item.answer
          };
        }
        if (item.recallHint) {
          return {
            label: item.recallHint,
            answer: item.answer ?? item.label
          };
        }
        return {
          label: "Answer",
          answer: item.answer ?? item.label
        };
      }

      function showResults(entries, allCorrect) {
        resultsPanel.innerHTML = `
          <strong>${allCorrect ? "Perfect recall!" : "Not quite."}</strong>
          <ul>
            ${entries
              .map(
                (entry, idx) => `
                  <li>
                    <span class="result-expected">
                      <span class="result-label">Card ${idx + 1} · ${entry.expected.label}</span>
                      <span class="result-answer">${entry.expected.answer}</span>
                    </span>
                    <span class="badge ${entry.correct ? "good" : "bad"}">
                      ${entry.correct ? "Correct" : `You: ${entry.actual || "-"}`}
                    </span>
                  </li>`
              )
              .join("")}
          </ul>
        `;
        resultsPanel.classList.add("show");
      }

      function showFailure(reason) {
        const entries = roundItems.map((item) => ({
          expected: buildExpectedLabel(item),
          actual: "",
          correct: false
        }));
        resultsPanel.innerHTML = `
          <strong>${reason}</strong>
          <ul>
            ${entries
              .map(
                (entry, idx) => `
                  <li>
                    <span class="result-expected">
                      <span class="result-label">Card ${idx + 1} · ${entry.expected.label}</span>
                      <span class="result-answer">${entry.expected.answer}</span>
                    </span>
                    <span class="badge bad">You: -</span>
                  </li>`
              )
              .join("")}
          </ul>
        `;
        resultsPanel.classList.add("show");
      }

      function lockInputs(locked) {
        inputGrid.querySelectorAll("input").forEach((input) => {
          input.disabled = locked;
        });
      }

      function checkAnswers() {
        if (phase !== "recall") return;
        clearInterval(timerId);
        timerId = null;
        const platformerRequired = platformerState.required;
        const entries = roundItems.map((item, index) => {
          const input = inputGrid.querySelector(`input[data-index="${index}"]`);
          const actual = input ? normalize(input.value) : "";
          return {
            expected: buildExpectedLabel(item),
            actual,
            correct: isCorrectAnswer(item, actual)
          };
        });
        const allCorrect =
          (!platformerRequired || (platformerState.completed && !platformerState.failed)) &&
          entries.every((entry) => entry.correct);
        updatePlatformerVisibility(false);
        if (allCorrect) {
          if (gameMode === "adventure") {
            adventureState.score += 10 + adventureState.difficulty;
            updateScore();
            openDraft();
            return;
          }
          streak += 1;
          updateScore();
          startRound();
          return;
        }
        lockInputs(true);
        renderCards(true);
        showResults(entries, allCorrect);
        if (submitBtn) {
          submitBtn.disabled = true;
        }
        if (nextBtn) {
          nextBtn.disabled = false;
        }
        if (gameMode === "adventure") {
          adventureState.lives = Math.max(0, adventureState.lives - 1);
        } else {
          if (nextBtn) {
            nextBtn.textContent = "Next round";
          }
          streak = 0;
        }
        setPhase("Round complete", "result");
        updateScore();
      }

      function beginRecallPhase() {
        if (phase !== "show") return;
        clearInterval(timerId);
        timerId = null;
        clearAdTimer();
        if (adEnabled && !adShownThisRound) {
          pendingSkipAfterAd = true;
          showAd();
          return;
        }
        hideAd();
        stopFog();
        stopGlitching();
        if (platformerState.required && !platformerState.completed) {
          platformerState.failed = true;
          lockInputs(true);
          renderCards(true);
          showFailure("Platformer failed");
          if (submitBtn) {
            submitBtn.disabled = true;
          }
          if (gameMode === "adventure") {
            adventureState.lives = Math.max(0, adventureState.lives - 1);
          } else {
            streak = 0;
          }
          setPhase("Round complete", "result");
          updateScore();
          updatePlatformerVisibility(false);
          return;
        }
        updatePlatformerVisibility(false);
        renderCards(false);
        lockInputs(false);
        if (submitBtn) {
          submitBtn.disabled = false;
        }
        setPhase("Type what you saw", "recall");
        focusFirstInput();
        setTimer(Number(recallInput.value), "Recall", () => {
          checkAnswers();
        });
      }

      function startRound(options = {}) {
        const { reuseItems = false, advanceRound = true } = options;
        const nextRound = advanceRound ? round + 1 : round;
        const categories = getActiveCategories(nextRound);
        if (!categories.length) {
          setPhase("Select at least one card type", "idle");
          return;
        }
        if (advanceRound) {
          round += 1;
        }
        updateScore();
        resetBoard();
        if (!reuseItems) {
          roundItems = pickItems();
          roundItemsBase = roundItems.map((item) => ({ ...item }));
        } else {
          roundItems = roundItemsBase.map((item) => ({ ...item }));
        }
        renderCards(true);
        renderInputs();
        lockInputs(true);
        if (submitBtn) {
          submitBtn.disabled = true;
        }
        if (nextBtn) {
          nextBtn.disabled = true;
        }
        resultsPanel.classList.remove("show");
        setPhase("Memorize the cards", "show");
        platformerState.required = isPlatformerEnabled();
        adEnabled = isAdEnabled();
        fogEnabled = isFogEnabled();
        adShownThisRound = false;
        pendingSkipAfterAd = false;
        hideAd();
        adActive = false;
        updatePlatformerVisibility(platformerState.required);
        startGlitching();
        if (fogEnabled) {
          startFog();
        } else {
          stopFog();
        }
        const revealSeconds = getRevealSeconds();
        scheduleAd(revealSeconds);
        setTimer(revealSeconds, "Reveal", () => {
          beginRecallPhase();
        });
      }

      function initAdventure() {
        adventureState.lives = 3;
        adventureState.score = 0;
        adventureState.difficulty = 0;
        adventureState.modifiers = {
          revealPenalty: 0,
          cardCount: 1,
          fog: false
        };
        adventureState.unlockedCategories = ["numbers"];
      }

      function getRevealSeconds() {
        const base = Number(revealInput.value) || 5;
        if (gameMode !== "adventure") {
          return base;
        }
        const penalty = adventureState.modifiers.revealPenalty || 0;
        return Math.max(1, base - penalty);
      }

      const modifierPool = [
        {
          id: "unlockLetters",
          title: "Unlock Letters",
          description: "Add letters to the card pool.",
          difficulty: 2,
          apply: () => {
            if (!adventureState.unlockedCategories.includes("letters")) {
              adventureState.unlockedCategories.push("letters");
            }
          }
        },
        {
          id: "unlockDirections",
          title: "Unlock Directions",
          description: "Add arrow directions to the card pool.",
          difficulty: 2,
          apply: () => {
            if (!adventureState.unlockedCategories.includes("directions")) {
              adventureState.unlockedCategories.push("directions");
            }
          }
        },
        {
          id: "unlockColors",
          title: "Unlock Colors",
          description: "Add colors to the card pool.",
          difficulty: 2,
          apply: () => {
            if (!adventureState.unlockedCategories.includes("colors")) {
              adventureState.unlockedCategories.push("colors");
            }
          }
        },
        {
          id: "mathOps",
          title: "Math Ops",
          description: "Numbers may require +, -, or ×.",
          difficulty: 3,
          apply: () => {
            adventureState.modifiers.mathOps = true;
          }
        },
        {
          id: "shortReveal",
          title: "Shorter Reveal",
          description: "-1s on reveal time (stacks).",
          difficulty: 2,
          apply: () => {
            adventureState.modifiers.revealPenalty = (adventureState.modifiers.revealPenalty || 0) + 1;
          }
        },
        {
          id: "moreCards",
          title: "Add a Card",
          description: "+1 card per round (stacks, max 10).",
          difficulty: 3,
          apply: () => {
            adventureState.modifiers.cardCount = Math.min(
              10,
              (adventureState.modifiers.cardCount || 1) + 1
            );
          }
        },
        {
          id: "backgroundColor",
          title: "Background Color Challenge",
          description: "Some cards ask for the background color.",
          difficulty: 2,
          apply: () => {
            adventureState.modifiers.backgroundColor = true;
          }
        },
        {
          id: "platformer",
          title: "Platformer Recall",
          description: "Complete a mini platformer during reveal.",
          difficulty: 3,
          apply: () => {
            adventureState.modifiers.platformer = true;
          }
        },
        {
          id: "glitch",
          title: "Glitching Reveal",
          description: "Cards flicker and black out during reveal.",
          difficulty: 2,
          apply: () => {
            adventureState.modifiers.glitch = true;
          }
        },
        {
          id: "fog",
          title: "Fog Reveal",
          description: "Clear fog by moving the cursor quickly.",
          difficulty: 2,
          apply: () => {
            adventureState.modifiers.fog = true;
          }
        },
        {
          id: "ads",
          title: "Pop-up Ads",
          description: "Random ads block cards during reveal.",
          difficulty: 2,
          apply: () => {
            adventureState.modifiers.ads = true;
          }
        },
        {
          id: "misleadColors",
          title: "Misleading Colors",
          description: "Color text can be wrong. Trust the background.",
          difficulty: 3,
          apply: () => {
            adventureState.modifiers.misleadColors = true;
          }
        },
        {
          id: "bonusLife",
          title: "Bonus Life",
          description: "Gain an extra life.",
          difficulty: 1,
          apply: () => {
            adventureState.lives += 1;
          }
        }
      ];

      function getAvailableModifiers() {
        return modifierPool.filter((modifier) => {
          if (modifier.id === "unlockLetters") {
            return !adventureState.unlockedCategories.includes("letters");
          }
          if (modifier.id === "unlockDirections") {
            return !adventureState.unlockedCategories.includes("directions");
          }
          if (modifier.id === "unlockColors") {
            return !adventureState.unlockedCategories.includes("colors");
          }
          if (modifier.id === "mathOps") {
            return !adventureState.modifiers.mathOps;
          }
          if (modifier.id === "shortReveal") {
            return (adventureState.modifiers.revealPenalty || 0) < 3;
          }
          if (modifier.id === "backgroundColor") {
            return !adventureState.modifiers.backgroundColor;
          }
          if (modifier.id === "platformer") {
            return !adventureState.modifiers.platformer;
          }
          if (modifier.id === "glitch") {
            return !adventureState.modifiers.glitch;
          }
          if (modifier.id === "fog") {
            return !adventureState.modifiers.fog;
          }
          if (modifier.id === "ads") {
            return !adventureState.modifiers.ads;
          }
          if (modifier.id === "moreCards") {
            return (adventureState.modifiers.cardCount || 1) < 10;
          }
          if (modifier.id === "misleadColors") {
            return (
              adventureState.unlockedCategories.includes("colors") &&
              !adventureState.modifiers.misleadColors
            );
          }
          if (modifier.id === "bonusLife") {
            return true;
          }
          return true;
        });
      }

      function openDraft() {
        if (gameMode !== "adventure") return;
        if (submitBtn) {
          submitBtn.disabled = true;
        }
        if (nextBtn) {
          nextBtn.disabled = true;
        }
        setPhase("Choose a modifier", "draft");
        renderDraftChoices();
      }

      function renderDraftChoices() {
        draftGrid.innerHTML = "";
        const pool = getAvailableModifiers();
        for (let i = pool.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [pool[i], pool[j]] = [pool[j], pool[i]];
        }
        const choices = pool.slice(0, 3);
        choices.forEach((modifier) => {
          const card = document.createElement("button");
          card.className = "draft-card";
          card.type = "button";
          card.innerHTML = `
            <small>Difficulty +${modifier.difficulty}</small>
            <strong>${modifier.title}</strong>
            <span>${modifier.description}</span>
          `;
          card.addEventListener("click", () => {
            modifier.apply();
            adventureState.difficulty += modifier.difficulty;
            updateScore();
            startRound({ reuseItems: false, advanceRound: true });
          });
          draftGrid.appendChild(card);
        });
      }

      function resetGame() {
        clearInterval(timerId);
        timerId = null;
        pausedState = null;
        timerState = null;
        updatePlatformerVisibility(false);
        stopFog();
        stopGlitching();
        clearAdTimer();
        hideAd();
        round = 0;
        streak = 0;
        if (gameMode === "adventure") {
          initAdventure();
        }
        roundItems = [];
        roundItemsBase = [];
        updateScore();
        timerPill.textContent = "00";
        if (timerFill) {
          timerFill.style.width = "100%";
        }
        setPhase("Waiting to start", "idle");
        resetBoard();
        if (submitBtn) {
          submitBtn.disabled = true;
        }
        if (nextBtn) {
          nextBtn.disabled = true;
          nextBtn.textContent = "Next round";
        }
      }

      function openPracticeModal() {
        setModalState(practiceModal, true);
      }

      function closePracticeModal() {
        setModalState(practiceModal, false);
      }

      practiceStart.addEventListener("click", () => {
        openPracticeModal();
      });

      adventureStart.addEventListener("click", () => {
        modeSelect.value = "adventure";
        updateModeUI();
        resetGame();
        startRound();
      });

      practiceCancel.addEventListener("click", () => {
        closePracticeModal();
      });

      practiceConfirm.addEventListener("click", () => {
        modeSelect.value = "practice";
        updateModeUI();
        resetGame();
        closePracticeModal();
        startRound();
      });

      practiceModal.addEventListener("click", (event) => {
        if (event.target === practiceModal) {
          closePracticeModal();
        }
      });

      interruptClose.addEventListener("click", () => {
        hideAd();
        if (pendingSkipAfterAd) {
          pendingSkipAfterAd = false;
          beginRecallPhase();
        }
      });

      window.addEventListener("mousemove", (event) => {
        if (!fogActive) return;
        const now = performance.now();
        const x = event.clientX;
        const y = event.clientY;
        if (fogLastMove.x !== null) {
          const dx = x - fogLastMove.x;
          const dy = y - fogLastMove.y;
          const dt = Math.max(1, now - fogLastMove.t);
          const speed = Math.hypot(dx, dy) / dt;
          if (speed >= 0.25) {
            clearFogAt(x, y, speed, fogLastMove.x, fogLastMove.y);
          }
        }
        fogLastMove = { x, y, t: now };
      });

      window.addEventListener("resize", () => {
        if (!fogActive) return;
        resizeFog();
        drawFog();
      });


      window.addEventListener("keydown", (event) => {
        if (phase !== "show" || !platformerState.enabled) return;
        const key = event.key.toLowerCase();
        if (event.key.startsWith("Arrow") || key === "a" || key === "d" || key === "w" || key === " ") {
          event.preventDefault();
        }
        if (event.key === "ArrowLeft" || key === "a") {
          platformerState.keys.left = true;
        }
        if (event.key === "ArrowRight" || key === "d") {
          platformerState.keys.right = true;
        }
        if (event.key === "ArrowUp" || event.key === " " || key === "w") {
          platformerState.keys.jump = true;
        }
      });

      window.addEventListener("keyup", (event) => {
        if (!platformerState.enabled) return;
        const key = event.key.toLowerCase();
        if (event.key === "ArrowLeft" || key === "a") {
          platformerState.keys.left = false;
        }
        if (event.key === "ArrowRight" || key === "d") {
          platformerState.keys.right = false;
        }
      });

      platformerLoop();

      pauseResume.addEventListener("click", () => {
        closePauseModal();
        if (pausedState && pausedState.phase) {
          if (pausedState.timer && pausedState.timer.remainingMs > 0) {
            setTimer(
              pausedState.timer.remainingMs / 1000,
              pausedState.timer.label,
              pausedState.timer.onComplete,
              pausedState.timer.totalSeconds
            );
          }
        }
        pausedState = null;
      });

      pauseRestart.addEventListener("click", () => {
        closePauseModal();
        resetGame();
        startRound();
      });

      pauseQuit.addEventListener("click", () => {
        closePauseModal();
        resetGame();
      });

      pauseModal.addEventListener("click", (event) => {
        if (event.target === pauseModal) {
          closePauseModal();
          if (pausedState && pausedState.phase) {
            setPhase(pausedState.phaseText, pausedState.phase);
            if (pausedState.timer && pausedState.timer.remainingMs > 0) {
              setTimer(
                pausedState.timer.remainingMs / 1000,
                pausedState.timer.label,
                pausedState.timer.onComplete
              );
            }
          }
          pausedState = null;
        }
      });

      if (submitBtn) {
        submitBtn.addEventListener("click", () => {
          checkAnswers();
        });
      }

      if (nextBtn) {
        nextBtn.addEventListener("click", () => {
          if (phase === "result" && gameMode === "adventure") {
            if (adventureState.lives > 0) {
              startRound({ reuseItems: true, advanceRound: false });
            } else {
              resetGame();
            }
          } else {
            startRound();
          }
        });
      }

      modeSelect.addEventListener("change", () => {
        updateModeUI();
        resetGame();
      });

      document.addEventListener("keydown", (event) => {
        if (practiceModal.classList.contains("show")) {
          if (event.key === "Enter") {
            event.preventDefault();
            practiceConfirm.click();
          } else if (event.key === "Escape") {
            event.preventDefault();
            closePracticeModal();
          }
          return;
        }
        if (event.key === "Escape") {
          event.preventDefault();
          if (pauseModal.classList.contains("show")) {
            closePauseModal();
            if (pausedState && pausedState.phase) {
              if (pausedState.timer && pausedState.timer.remainingMs > 0) {
                setTimer(
                  pausedState.timer.remainingMs / 1000,
                  pausedState.timer.label,
                  pausedState.timer.onComplete,
                  pausedState.timer.totalSeconds
                );
              }
            }
            pausedState = null;
          } else {
            openPauseModal();
          }
          return;
        }
        if (event.key !== "Enter") return;
        if (phase === "show") {
          queueSkipAfterAd();
        } else if (phase === "recall") {
          checkAnswers();
        } else if (phase === "result") {
          if (gameMode === "adventure") {
            if (adventureState.lives > 0) {
              startRound({ reuseItems: false, advanceRound: true });
            } else {
              resetGame();
            }
          } else {
            startRound();
          }
        }
      });

      updateModeUI();
      resetGame();
      updateCategoryControls();
    </script>
  </body>
</html>
